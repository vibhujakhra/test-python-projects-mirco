import io
import os
import json
import pandas as pd
from typing import List
from datetime import datetime
from fastapi import APIRouter, UploadFile, HTTPException, status
from fastapi.responses import StreamingResponse

from sqlalchemy import update
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from starlette import status
from starlette.background import BackgroundTasks

from schemas.admin_schema import RoleListResponse, RoleRequestSchema, RoleUpdateSchema, StatusUpdateSchema, \
    UserCreateRequest, UserUpdateRequest
from db.models.rbac import AdminRole, Reportee, User, UserMetaData, RelationManagerUserMapping, UserChangeLog
from rb_utils.database import sqldb

from services.role_service import RoleRepository
from services.user_admin_services import UserServices
from utils.exceptions import DatabaseConnectionException
from utils.verification import get_hashed_password, autogenerated_password_reset

router = APIRouter()


@router.post("/create_role/")
async def create_role(role_data: RoleRequestSchema):
    """
    The create_role function creates a new role in the database.
        Args:
            role_data (RoleRequestSchema): The data to be used for creating a new role.

    :param role_data: RoleRequestSchema: Validate the data that is passed in
    :return: A dictionary with the following keys:
    """
    role_create_response = await RoleRepository.create_role(role_data=role_data)
    return role_create_response


@router.patch("/update_role/")
async def update_role(update_data: RoleUpdateSchema):
    """
    The update_role function updates a role in the database.
        Args:
            update_data (RoleUpdateSchema): The data to be updated for the role.
    :param update_data: RoleUpdateSchema: Pass the data that will be used to update the role
    :return: A dict with the following keys:
    """
    update_role_response = await RoleRepository.update_role(update_data=update_data)
    return update_role_response


@router.get("/get_existing_roles_list/")
async def get_existing_role_list(group_code: str = None) -> List[RoleListResponse]:
    """
    The get_existing_role_list function returns a list of existing roles in the database.
        Args:
            group_code (str): The code for the group to which the role belongs.
    :param group_code: str: Filter the role list based on group code
    :return: A list of role list response
    """
    try:
        role_list = await RoleRepository.get_existing_role(group_code=group_code)
        response = []
        for role in role_list:
            response.append(RoleListResponse(
                role_id=role.id,
                role_name=role.role_name,
                group_type=role.group.name,
                group_code=role.group.code,
                status=role.is_active,
                has_create_update_access=role.has_create_update_access,
                module_ids=[id.module_id for id in role.role_permissions if id.is_active == True]
            )) 
        return response
    except Exception as e:
        raise DatabaseConnectionException(f"Exception encounter {str(e)} while fetching records.")


@router.post("/create_user/")
async def create_user(request: UserCreateRequest, background_tasks: BackgroundTasks):
    """
    The create_user function creates a new user in the database.
        Args:
            request (UserCreateRequest): A UserCreateRequest object containing all of the necessary information to create a new user.
    :param request: UserCreateRequest: Get the data from the request body
    :return: A dictionary with a message key
    """
    try:
        new_data_dict = {}
        user_data = request.dict()
        user_meta_keys = ["dealer_code", "workshop_code", "oem_code", "insurer_code"]
        creator_editor = user_data.pop('creator_editor')
        rm_keys = ["relationship_manager_id"]

        # push data for related tables
        user_meta_data = {key: user_data.pop(key) for key in user_meta_keys}
        rm_data = {key: user_data.pop(key) for key in rm_keys}
        reportee_ids = user_data.pop("reportee_ids")
        reporting_manager_id = user_data.pop("reporting_manager_id")
        old_password = f"{request.first_name}{request.mobile_no[0:5]}"
        # user create
        user = await User.create(is_active=True, hashed_password=get_hashed_password(password=old_password), **user_data)
        new_data_dict.update({'user_dict': await type_conversion(user)})
        if user_meta_data:
            user_meta_data["user_id"] = user.id
            user_metadata = await UserMetaData.create(**user_meta_data)
            new_data_dict.update({'user_meta_data_dict': await type_conversion(user_metadata)})
        if rm_data:
            rm_data["user_id"] = user.id
            rm_data = await RelationManagerUserMapping.create(**rm_data)
            new_data_dict.update({'rm_data_dict': await type_conversion(rm_data)})
        reporting_data = []
        if reporting_manager_id:
            reporting_data.append({
                "user_id": user.id,
                "manager_id": reporting_manager_id,
                "is_active": True
            })

        reportee_data = []
        if reportee_ids:
            reportee_data = [{"user_id": i, "manager_id": user.id, "is_active": True} for i in reportee_ids]

        push_data = reporting_data + reportee_data

        if push_data:
            await sqldb.execute(Reportee.__table__.insert(), push_data)
            await sqldb.commit()

        log_maintainer = {
            "user_id": str(user.id),
            "new_data": json.dumps(new_data_dict),
            "creator_editor": creator_editor
        }
        await UserChangeLog.create(**log_maintainer)
        await autogenerated_password_reset(background_tasks=background_tasks,old_password=old_password,email=request.email)
        return {"message": "User Created Successfully and Email is successfully sent on the registered email Id",
                "status_code": status.HTTP_200_OK
                }


    except Exception:
        raise HTTPException(    
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="COULD NOT CREATE USER",
            )


@router.patch("/update_user/")
async def update_user(request: UserUpdateRequest):
    """
    The update_user function updates the user details in the database.
        Args:
            request (UserUpdateRequest): The UserUpdateRequest object containing all of the necessary information to update a user.
    :param request: UserUpdateRequest: Get the data from the request
    :return: A dict with the key message and value as &quot;successfully updated user&quot;
    """
    try:
        old_data_dict = {}
        new_data_dict = {}
        user_data = {key: value for key, value in request.dict().items() if value is not None}
        user_id = user_data.pop("user_id")
        creator_editor = user_data.pop('creator_editor')

        user_meta_keys = ["dealer_code", "workshop_code", "oem_code", "insurer_code"]
        user_meta_data = {key: user_data.pop(key) for key in user_meta_keys if user_data.get(key)}
        rm_id = user_data.pop("relationship_manager_id") if user_data.get(
            "relationship_manager_id") is not None else None
        reportee_ids = user_data.pop("reportee_ids") if user_data.get("reportee_ids") is not None else None
        reporting_manager_id = user_data.pop("reporting_manager_id") if user_data.get(
            "reporting_manager_id") is not None else None

        user = (await sqldb.execute(select(User).where(
            User.id == user_id).options(selectinload(User.user_meta_data)))
                ).scalars().first()
        user_dict = await type_conversion(user)
        user_meta_dict = await type_conversion(user.user_meta_data[0])
        old_data_dict.update({
            'user': user_dict,
            'user_meta_data': user_meta_dict})
        if user_data:
            await user.update(key=user_id, **user_data)
            new_data_dict.update({"user": await type_conversion(user)})
        if user_meta_data:
            user_meta_obj = user.user_meta_data[0]
            if user_meta_obj:
                await user_meta_obj.update(key=user_meta_obj.id, **user_meta_data)
            else:
                await UserMetaData.create(user_id=user_id, **user_meta_data)
            new_data_dict.update({"user_meta_data": await type_conversion(user_meta_obj)})

        if rm_id:
            new_data_dict.update({'relationship_manager_id': rm_id})
            rm_obj = (await sqldb.execute(select(RelationManagerUserMapping).where(
                RelationManagerUserMapping.user_id == user.id))
                      ).scalars().first()
            old_data_dict.update({'relationship_manager_id': str(rm_obj.relationship_manager_id)})
            if rm_obj:
                if str(rm_obj.relationship_manager_id) != rm_id:
                    await rm_obj.update(key=rm_obj.id, relationship_manager_id=rm_id)
            else:
                rm_data = {
                    "user_id": user_id,
                    "relationship_manager_id": rm_id
                }
                await RelationManagerUserMapping.create(**rm_data)

        if reportee_ids:
            new_data_dict.update({"reportee_ids": reportee_ids})

            existing_reportees = (await sqldb.execute(select(Reportee.user_id).where(
                Reportee.manager_id == user_id))).scalars().all()

            existing_reportee_set = set(map(str, existing_reportees))
            new_reportees_set = set(reportee_ids)

            reportees_to_inactive = list(existing_reportee_set - new_reportees_set)
            existing_reportess_to_active = list(existing_reportee_set.intersection(new_reportees_set))
            old_data_dict.update({"reportee_ids": existing_reportess_to_active})
            reportees_to_create = list(new_reportees_set - existing_reportee_set)

            if reportees_to_inactive:
                await sqldb.execute(update(Reportee.__table__).where(
                    Reportee.user_id.in_(reportees_to_inactive)).values(is_active=False))
                await sqldb.commit()

            if existing_reportess_to_active:
                await sqldb.execute(update(Reportee.__table__).where(
                    Reportee.user_id.in_(existing_reportess_to_active)).values(is_active=True))
                await sqldb.commit()

            if reportees_to_create:
                reportee_data = {}
                for id in reportees_to_create:
                    reportee_data.update({
                        "user_id": id,
                        "manager_id": user_id,
                        "is_active": True
                    })

                await sqldb.execute(Reportee.__table__.insert(), reportee_data)
                await sqldb.commit()

        if reporting_manager_id:
            new_data_dict.update({"reporting_manager_id": reporting_manager_id})
            reporting_manager_obj = (await sqldb.execute(select(Reportee).where(
                Reportee.user_id == user_id))).scalars().first()

            if reporting_manager_obj:
                if (reporting_manager_id != reporting_manager_obj.manager_id):
                    await reporting_manager_obj.update(
                        key=reporting_manager_obj.id,
                        manager_id=reporting_manager_id
                    )
            else:
                await Reportee.create(**{
                    "user_id": str(user_id),
                    "manager_id": reporting_manager_id
                })
            old_data_dict.update({"reporting_manager_id": reporting_manager_obj.id})

            await UserChangeLog.create(**{
                "user_id": str(user.id),
                "old_data": json.dumps(old_data_dict),
                "new_data": json.dumps(new_data_dict),
                "creator_editor": creator_editor
            })

        return {"message": "SUCCESSFULLY UPDATED USER"}

    except Exception:
        raise HTTPException(    
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="COULD NOT UPDATE USER",
            )


@router.post("/user_bulk_upload/")
async def user_bulk_upload(background_tasks: BackgroundTasks, user_csv: UploadFile, admin_role_id: str, group_type: str):
    """
    The user_bulk_upload function is used to upload a csv file containing user data.
    The function takes in the following parameters:
        - user_csv: The csv file containing the users' information.
        - admin_role_id: The id of the admin role that will be assigned to all users in this bulk upload.
            This parameter is required for all group types except 'admin'. For admins, it can be left blank or set as None.

    :param user_csv: UploadFile: Get the uploaded csv file
    :param admin_role_id: str: Get the admin role id of the logged in user
    :param group_type: str: Determine the type of group to which the user belongs
    :return: A csv with the error messages
    """
    try:
        error_records = {}
        bulk_data = pd.read_csv(user_csv.file)
        session = sqldb

        df = bulk_data.copy()
        if not len(df.index):
            raise HTTPException(    
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="EMPTY CSV UPLOADED",
            )

        df.columns = list(map(lambda x: x.replace(" ", "_").lower().strip(),df.columns))
        df.fillna("NAN", inplace=True); df.replace("NAN",None, inplace=True)
        df = df.applymap(lambda x: str(x) if x else x)

        # Checking for uploaded csv for group-wise field requirements and trimming the df in case of discrepancy
        corrupt_index = await UserServices.validate_df(group_type=group_type, df=df, error_records=error_records)

        if not corrupt_index:
            df["admin_role_id"] = admin_role_id
            df["user_id"] = None

            # Group wise headers 
            user_headers, user_meta_headers ,relationship_manager_headers, reporting_headers =\
                await UserServices.get_table_headers(group_type=group_type)

            # User bulk creation
            if len(df.index):
                await UserServices.user_bulk_create(background_tasks=background_tasks,df=df, error_records=error_records, user_headers=user_headers, session=session)

            # User Meta bulk creation
            if user_meta_headers and len(df.index):
                await UserServices.user_meta_bulk_create(df=df,user_meta_headers=user_meta_headers, session=session)

            # RelationShip Manager Creation
            if relationship_manager_headers and len(df.index):
                await UserServices.rm_bulk_create(df=df, relationship_manager_headers=relationship_manager_headers, \
                    error_records=error_records, session=session)

            # Reporting bulk Creation
            if reporting_headers and len(df.index):
                await UserServices.reporting_bulk_create(df=df, reporting_headers=reporting_headers, group_type=group_type,\
                    error_records=error_records, session=session)

        if error_records:
            await session.rollback()
            bulk_data["error_message"] = None
            bulk_data.loc[[i for i in error_records], "error_message"] = [value for key, value in error_records.items()]
            csv_string = bulk_data.to_csv()
            headers = {
                "Content-Disposition": f"attachment; filename={user_csv.filename}.csv",
                "Content-Type": "text/csv",
            }
            return StreamingResponse(io.StringIO(csv_string), media_type="text/csv", headers=headers)

        await session.commit()
        return {
            "error_csv": None
        }

    except Exception as e:
        raise HTTPException(    
                status_code=e.status_code or status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=e.detail or "BULK UPLOAD FAILED",
            )


@router.patch("/update_all_status/")
async def update_status(update_data: StatusUpdateSchema):
    """
    The update_status function updates the status of a user or admin role.
        Args:
            update_data (StatusUpdateSchema): A StatusUpdateSchema object containing the id and is_active value to be updated.
    :param update_data: StatusUpdateSchema: Validate the data passed in
    :return: A dictionary with the message key and value
    """
    try:
        model = AdminRole if update_data.role_id else User
        key = update_data.role_id or update_data.user_id
        await model.update(key=key, **{"is_active": update_data.is_active})
        return {"message": "Entry has been updated"}
    except Exception as e:
        raise DatabaseConnectionException(f"Exception encounter {str(e)} while updating records.")


@router.get("/get_user_templates/")
async def get_user_templates(group_type: str):
    try:
        template_loc = os.getcwd()+"/bulk_upload_templates/"+group_type.upper()+".csv"
        csv_string = pd.read_csv(template_loc).to_csv()
        headers = {
            "Content-Disposition": f"attachment; filename={group_type.upper()}.csv",
            "Content-Type": "text/csv",
        }
        return StreamingResponse(io.StringIO(csv_string), media_type="text/csv", headers=headers)

    except Exception:
        return {"message": "TEMPLATE NOT FOUND"}


async def type_conversion(type_obj):
    """
    The type_conversion function takes in a type object and returns a dictionary of the type's attributes.
        The function also converts the created_at, modified_at, id, and user_id fields to strings.
        If there is no created_at field or if it is None then it will not be included in the returned dictionary.

    :param type_obj: Pass the object of the type that is to be converted
    :return: A dictionary object with type casted values
    """
    try:
        type_dict = type_obj.__dict__.copy()
        del type_dict["_sa_instance_state"]
        if type_dict.get('created_at'):
            type_dict['created_at'] = datetime.strftime(type_dict.get('created_at'), "%Y-%m-%d")
        if "modified_at" in type_dict:
            type_dict['modified_at'] = datetime.strftime(type_dict.get('modified_at'), "%Y-%m-%d")
        if "id" in type_dict:
            type_dict['id'] = str(type_dict['id'])
        if 'user_id' in type_dict:
            type_dict['user_id'] = str(type_dict['user_id'])
        if 'user_meta_data' in type_dict:
            type_dict.pop('user_meta_data')
        return type_dict  
    except Exception:
        pass

