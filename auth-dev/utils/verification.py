from datetime import datetime, timedelta

import bcrypt
import jwt
from fastapi_users.manager import BaseUserManager
from fastapi_users import exceptions, models
from sqlalchemy.future import select
from db.models.rbac import User
from sdk.producer import AsyncKafkaProducer
from starlette.background import BackgroundTasks
from pydantic import EmailStr
from apis.version1.user_manager import get_user_manager
from fastapi import Body, Depends, HTTPException, status
from db.session import async_db_session
from settings import RESET_PASSWORD_KEY, VERIFICATION_EMAIL_SUBJECT, RESET_DOMAIN_ADDRESS, RESET_PASSWORD_JWT_TOKEN_TIME


def get_hashed_password(password: str) -> str:
    byte_hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
    hashed_password_into_string = byte_hashed_password.decode('UTF-8')
    return hashed_password_into_string


def decode_jwt(token: str, jwt_algorithm: str) -> dict:
    reset_token_data = jwt.decode(token, key=RESET_PASSWORD_KEY, algorithms=jwt_algorithm)
    return reset_token_data


def encode_jwt(payload_data: dict) -> str:
    token = jwt.encode(payload=payload_data, key=RESET_PASSWORD_KEY)
    return token


def get_token_expiry(validity_seconds=900) -> int:
    token_expiry_time = int(
        (datetime.now().replace(second=0, microsecond=0) + timedelta(seconds=validity_seconds)).timestamp())
    return token_expiry_time


async def autogenerated_password_reset(background_tasks: BackgroundTasks, old_password: str, email: EmailStr = Body(..., embed=True),
                                       user_manager: BaseUserManager[models.UP, models.ID] = Depends(get_user_manager)):
    try:
        user = (await async_db_session.execute(select(User).filter(User.email == email))).scalars().first()
        payload_data = {
            "email": email,
            "exp_time": get_token_expiry(RESET_PASSWORD_JWT_TOKEN_TIME)
        }
        token = encode_jwt(payload_data=payload_data)
        email_request = {
            "template_format_kwargs": {
                "reset_password_link": f'{RESET_DOMAIN_ADDRESS}/reset-password?'f'token={token}',
                "old_password": old_password,
                "user_name": user.full_name,
                "email_id": email
            },
            "template_slug": "autogenerate_reset_password",
            "subject": VERIFICATION_EMAIL_SUBJECT,
            "email": [email]
        }
        background_tasks.add_task(AsyncKafkaProducer.push_email_to_kafka_topic, data=email_request)

    except exceptions.UserNotExists:
        await async_db_session.rollback()
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="USER_NOT_EXISTS",
        )
    return f"Email sent successfully. f'{RESET_DOMAIN_ADDRESS}/reset-password?token={token}"
